<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="nl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MutatiesActionBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BRMO BRK verschil service</a> &gt; <a href="index.source.html" class="el_package">nl.b3p.brmo.verschil.stripes</a> &gt; <span class="el_source">MutatiesActionBean.java</span></div><h1>MutatiesActionBean.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 B3Partners B.V.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package nl.b3p.brmo.verschil.stripes;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.node.ObjectNode;
import net.sourceforge.stripes.action.*;
import net.sourceforge.stripes.validation.*;
import nl.b3p.brmo.verschil.util.ConfigUtil;
import nl.b3p.brmo.verschil.util.ResultSetJSONSerializer;
import org.apache.commons.io.FileUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * Mutaties actionbean. Haalt mutaties uit de BRMO RSGB database voor de gegeven
 * periode.
 * &lt;br&gt; Voorbeeld url: {@code /rest/mutaties?van=2018-08-01} of
 * {@code /rest/mutaties?van=2018-08-01&amp;tot=2018-09-01} .
 *
 * @author mark
 * @since 1.0
 */
@RestActionBean
@UrlBinding(&quot;/rest/{location}&quot;)
<span class="nc" id="L53">public class MutatiesActionBean implements ActionBean, ValidationErrorHandler {</span>

<span class="nc" id="L55">    private static final Log LOG = LogFactory.getLog(MutatiesActionBean.class);</span>
<span class="nc" id="L56">    private final SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span>
    /**
     * verplichte datum begin periode. Datum in yyyy-mm-dd formaat, de
     * begindatum is deel van de periode.
     */
    @Validate(required = true, mask = &quot;\\d{4}-\\d{2}-\\d{2}&quot;)
    private Date van;
    /**
     * optionele datum einde periode, default is datum van aanroepen. Datum in
     * yyyy-mm-dd formaat, de einddatum is deel van de periode, dwz. tot-en-met.
     */
<span class="nc" id="L67">    @Validate(mask = &quot;\\d{4}-\\d{2}-\\d{2}&quot;)</span>
    private Date tot = new Date();

    /**
     * optionele format parameter, default is {@code json}.
     */
<span class="nc" id="L73">    @Validate</span>
    private String f = &quot;json&quot;;

    private ActionBeanContext context;
    private long copied;
<span class="nc" id="L78">    private boolean errorCondition = false;</span>

    // als gekoppeld wordt met een table
<span class="nc" id="L81">    private static final String TAX_JOIN_CLAUSE_TBL = new StringBuilder()</span>
<span class="nc" id="L82">            .append(&quot;tax.belastingplichtige tax ON ( &quot;)</span>
<span class="nc" id="L83">            .append(&quot;      q.ka_kad_gemeentecode=trim(LEADING '0' from tax.gemeentecode) &quot;)</span>
<span class="nc" id="L84">            .append(&quot;  AND q.ka_sectie=tax.sectie &quot;)</span>
<span class="nc" id="L85">            .append(&quot;  AND q.ka_perceelnummer=trim(LEADING '0' from tax.perceelnummer) &quot;)</span>
            // deelperceel nummer wordt niet gevuld vanuit BRK want dat bestaat niet meer, dus ook niet in rsgb
            //.append(&quot;  AND coalesce(q.ka_deelperceelnummer,'')=coalesce(trim(LEADING '0' from tax.deelperceelnummer),'') &quot;)
<span class="nc" id="L88">            .append(&quot;  AND coalesce(q.ka_appartementsindex,'')=coalesce(trim(LEADING '0' from tax.appartementsindex),'') )&quot;).toString();</span>

    // als gekoppeld wordt met een view
<span class="nc" id="L91">    private static final String TAX_JOIN_CLAUSE_VW = new StringBuilder()</span>
<span class="nc" id="L92">            .append(&quot;tax.belastingplichtige tax ON ( &quot;)</span>
<span class="nc" id="L93">            .append(&quot;      q.gemeentecode=trim(LEADING '0' from tax.gemeentecode) &quot;)</span>
<span class="nc" id="L94">            .append(&quot;  AND q.sectie=tax.sectie &quot;)</span>
<span class="nc" id="L95">            .append(&quot;  AND q.perceelnummer=trim(LEADING '0' from tax.perceelnummer) &quot;)</span>
            // deelperceel nummer wordt niet gevuld vanuit BRK want dat bestaat niet meer, dus ook niet in rsgb
            //.append(&quot;  AND coalesce(q.deelperceelnummer,'')=coalesce(trim(LEADING '0' from tax.deelperceelnummer),'') &quot;)
            //.append(&quot;  AND coalesce(q.deelperceelnummer,'')=coalesce(trim(LEADING '0' from tax.deelperceelnummer),'') &quot;)
<span class="nc" id="L99">            .append(&quot;  AND coalesce(q.appartementsindex,'')=coalesce(trim(LEADING '0' from tax.appartementsindex),'') )&quot;).toString();</span>

    /**
     * context param voor view vb_koz_rechth.
     *
     * @see #initParams()
     */
<span class="nc" id="L106">    private String VIEW_KOZ_RECHTHEBBENDE = &quot;vb_koz_rechth&quot;;</span>
    /**
     * context param voor view vb_kad_onrrnd_zk_adres.
     *
     * @see #initParams()
     */
<span class="nc" id="L112">    private String VIEW_KAD_ONRRND_ZK_ADRES = &quot;vb_kad_onrrnd_zk_adres&quot;;</span>
    /**
     * context param voor view vb_kad_onrrnd_zk_archief.
     *
     * @see #initParams()
     */
<span class="nc" id="L118">    private String VIEW_KAD_ONRRND_ZK_ARCHIEF = &quot;vb_kad_onrrnd_zk_archief&quot;;</span>
    /**
     * context param voor view JDBC_FETCH_SIZE.
     *
     * @see #initParams()
     */
<span class="nc" id="L124">    private int JDBC_FETCH_SIZE = 1000;</span>

    @ValidationMethod(when = ValidationState.NO_ERRORS)
    public void validateVanBeforeTot(ValidationErrors errors) {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (tot.before(van)) {</span>
<span class="nc" id="L129">            errors.addGlobalError(new SimpleError(&quot;`van` datum is voor `tot` datum&quot;));</span>
        }
<span class="nc" id="L131">    }</span>

    @Override
    public Resolution handleValidationErrors(ValidationErrors errors) throws Exception {
<span class="nc" id="L135">        StringBuilder msg = new StringBuilder(&quot;Validatiefout(en): \n&quot;);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (errors.hasFieldErrors()) {</span>
<span class="nc" id="L137">            errors.entrySet().stream().forEach((entry) -&gt; {</span>
<span class="nc" id="L138">                entry.getValue().stream().map((e) -&gt; {</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L140">                        msg.append(&quot;veld: &quot;).append(entry.getKey()).append(&quot;, waarde: &quot;);</span>
<span class="nc" id="L141">                        msg.append(e.getFieldValue()).append(&quot;, melding: &quot;);</span>
                    }
<span class="nc" id="L143">                    return e;</span>
<span class="nc" id="L144">                }).forEach((e) -&gt; {</span>
<span class="nc" id="L145">                    msg.append(e.getMessage(Locale.ROOT)).append(&quot; \n&quot;);</span>
<span class="nc" id="L146">                });</span>
<span class="nc" id="L147">            });</span>
        }
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (errors.get(ValidationErrors.GLOBAL_ERROR) != null) {</span>
<span class="nc" id="L150">            errors.get(ValidationErrors.GLOBAL_ERROR).stream().forEach((e) -&gt; {</span>
<span class="nc" id="L151">                msg.append(e.getMessage(Locale.ROOT));</span>
<span class="nc" id="L152">            });</span>
        }

<span class="nc" id="L155">        return new ErrorResolution(HttpServletResponse.SC_BAD_REQUEST, msg.toString());</span>
    }

    @GET
    @DefaultHandler
    public Resolution get() throws IOException {
<span class="nc" id="L161">        errorCondition = false;</span>
<span class="nc" id="L162">        LOG.trace(&quot;`get` met params: van=&quot; + van + &quot; tot=&quot; + tot + &quot;, format: &quot; + f);</span>
<span class="nc" id="L163">        LOG.info(&quot;Uitvoeren opdracht met params: van=&quot; + df.format(van) + &quot; tot=&quot; + df.format(tot));</span>
<span class="nc" id="L164">        this.initParams();</span>
        // maak werkdirectory en werkbestand
<span class="nc" id="L166">        Path workPath = Files.createTempDirectory(</span>
<span class="nc" id="L167">                Paths.get(System.getProperty(&quot;java.io.tmpdir&quot;)),</span>
                &quot;brkmutsvc&quot;
        );
<span class="nc" id="L170">        File workDir = workPath.toFile();</span>
<span class="nc" id="L171">        workDir.deleteOnExit();</span>
<span class="nc" id="L172">        File workZip = Files.createTempFile(&quot;brkmutsvc&quot;, &quot;.zip&quot;).toFile();</span>
<span class="nc" id="L173">        workZip.deleteOnExit();</span>

        // uitvoeren queries
        // 2.3
<span class="nc" id="L177">        LOG.debug(&quot;Ophalen nieuwe onroerende zaken&quot;);</span>
<span class="nc" id="L178">        long nwOnrrgd = this.getNieuweOnroerendGoed(workDir);</span>
<span class="nc" id="L179">        LOG.info(&quot;Aantal nieuwe onroerende zaken is: &quot; + nwOnrrgd);</span>
        // 2.4
<span class="nc" id="L181">        LOG.debug(&quot;Ophalen gekoppelde objecten&quot;);</span>
<span class="nc" id="L182">        long gekoppeld = this.getGekoppeldeObjecten(workDir);</span>
<span class="nc" id="L183">        LOG.info(&quot;Aantal gekoppeld objecten: &quot; + gekoppeld);</span>
        // 2.5
<span class="nc" id="L185">        LOG.debug(&quot;Ophalen vervallen objecten&quot;);</span>
<span class="nc" id="L186">        long vervallen = this.getVervallenOnroerendGoed(workDir);</span>
<span class="nc" id="L187">        LOG.info(&quot;Aantal vervallen: &quot; + vervallen);</span>
        // 2.6
<span class="nc" id="L189">        LOG.debug(&quot;Ophalen object verkopen&quot;);</span>
<span class="nc" id="L190">        long verkopen = this.getVerkopen(workDir);</span>
<span class="nc" id="L191">        LOG.info(&quot;Aantal verkopen: &quot; + verkopen);</span>
        // 2.7
<span class="nc" id="L193">        LOG.debug(&quot;Ophalen oppervlakte veranderd objecten&quot;);</span>
<span class="nc" id="L194">        long oppVeranderd = this.getGewijzigdeOpp(workDir);</span>
<span class="nc" id="L195">        LOG.info(&quot;Aantal oppervlakte veranderd: &quot; + oppVeranderd);</span>
        // 2.8
<span class="nc" id="L197">        LOG.debug(&quot;Ophalen nieuwe subjecten&quot;);</span>
<span class="nc" id="L198">        long nwSubject = this.getNieuweSubjecten(workDir);</span>
<span class="nc" id="L199">        LOG.info(&quot;Aantal nieuwe subjecten: &quot; + nwSubject);</span>
        // 2.9
<span class="nc" id="L201">        LOG.debug(&quot;Ophalen BSN aangepast&quot;);</span>
<span class="nc" id="L202">        long bsn = this.getBSNAangevuld(workDir);</span>
<span class="nc" id="L203">        LOG.info(&quot;Aantal aangepast bsn: &quot; + bsn);</span>

<span class="nc bnc" id="L205" title="All 14 branches missed.">        if (nwOnrrgd &lt; 0 || gekoppeld &lt; 0 || vervallen &lt; 0 || verkopen &lt; 0 || oppVeranderd &lt; 0 || nwSubject &lt; 0 || bsn &lt; 0) {</span>
<span class="nc" id="L206">            errorCondition = true;</span>
<span class="nc" id="L207">            LOG.trace(&quot;Een van de queries heeft een onverwacht resultaat gegeven, errorCondition=&quot;+errorCondition);</span>
        }
        // zippen resultaat in workZip
<span class="nc" id="L210">        try (ZipOutputStream zs = new ZipOutputStream(Files.newOutputStream(workZip.toPath()))) {</span>
<span class="nc" id="L211">            LOG.debug(&quot;Aanmaken van zip bestand: &quot; + workZip);</span>
<span class="nc" id="L212">            Files.walk(workPath)</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                    .filter(path -&gt; !Files.isDirectory(path))</span>
<span class="nc" id="L214">                    .forEach(path -&gt; {</span>
<span class="nc" id="L215">                        ZipEntry zipEntry = new ZipEntry(workPath.relativize(path).toString());</span>
                        try {
<span class="nc" id="L217">                            LOG.debug(&quot;Toevoegen van bestand: &quot; + zipEntry);</span>
<span class="nc" id="L218">                            zs.putNextEntry(zipEntry);</span>
<span class="nc" id="L219">                            Files.copy(path, zs);</span>
<span class="nc" id="L220">                            zs.closeEntry();</span>
<span class="nc" id="L221">                        } catch (IOException e) {</span>
<span class="nc" id="L222">                            System.err.println(e);</span>
<span class="nc" id="L223">                        }</span>
<span class="nc" id="L224">                    });</span>
        }

<span class="nc" id="L227">        return new StreamingResolution(&quot;application/zip&quot;) {</span>
            @Override
            public void stream(HttpServletResponse response) throws Exception {
<span class="nc" id="L230">                copied = FileUtils.copyFile(workZip, response.getOutputStream());</span>
<span class="nc" id="L231">                LOG.debug(&quot;bytes copied: &quot; + copied);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                if (errorCondition) {</span>
<span class="nc" id="L233">                    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span>
                }
<span class="nc" id="L235">                FileUtils.deleteQuietly(workDir);</span>
<span class="nc" id="L236">                FileUtils.deleteQuietly(workZip);</span>
<span class="nc" id="L237">            }</span>
<span class="nc" id="L238">        }.setFilename(&quot;mutaties_&quot; + df.format(van) + &quot;_&quot; + df.format(tot) + &quot;.zip&quot;)</span>
                // 0! .setLength(copied)
<span class="nc" id="L240">                .setAttachment(true)</span>
<span class="nc" id="L241">                .setLastModified(tot.getTime());</span>
    }

    /**
     * ophalen nieuwe percelen en appartementsrechten. [2.3].
     *
     * @param workDir directory waar resultaat wordt neergezet
     * @return aantal nieuw
     */
    private long getNieuweOnroerendGoed(File workDir) {
<span class="nc" id="L251">        StringBuilder sql = new StringBuilder(&quot;SELECT DISTINCT &quot;)</span>
<span class="nc" id="L252">                .append(&quot;o.kad_identif, &quot;)</span>
<span class="nc" id="L253">                .append(&quot;o.dat_beg_geldh, &quot;)</span>
<span class="nc" id="L254">                .append(&quot;tax.gemeentecode, &quot;)</span>
<span class="nc" id="L255">                .append(&quot;tax.perceelnummer, &quot;)</span>
<span class="nc" id="L256">                .append(&quot;tax.deelperceelnummer, &quot;)</span>
<span class="nc" id="L257">                .append(&quot;tax.sectie, &quot;)</span>
<span class="nc" id="L258">                .append(&quot;tax.appartementsindex, &quot;)</span>
<span class="nc" id="L259">                .append(&quot;tax.kpr_nummer, &quot;)</span>
<span class="nc" id="L260">                .append(&quot;q.grootte_perceel, &quot;)</span>
<span class="nc" id="L261">                .append(&quot;q.x, &quot;)</span>
<span class="nc" id="L262">                .append(&quot;q.y, &quot;)</span>
<span class="nc" id="L263">                .append(&quot;z.ar_teller AS aandeel_teller, &quot;)</span>
<span class="nc" id="L264">                .append(&quot;z.ar_noemer AS aandeel_noemer, &quot;)</span>
<span class="nc" id="L265">                .append(&quot;z.fk_3avr_aand AS rechtcode, &quot;)</span>
<span class="nc" id="L266">                .append(&quot;avr.omschr_aard_verkregenr_recht AS rechtomschrijving, &quot;)</span>
<span class="nc" id="L267">                .append(&quot;h.fk_sc_rh_koz_kad_identif AS ontstaan_uit &quot;)</span>
                // TODO evt opzoeken kadastrale aanduiding in perceel/app_re archief
                // .append(&quot;arch.ka_kad_gemeentecode AS ontstaan_uit_gemeentecode, &quot;)
                // .append(&quot;arch.ka_perceelnummer AS ontstaan_uit_perceelnummer, &quot;)
                // .append(&quot;arch.ka_deelperceelnummer AS ontstaan_uit_deelperceelnummer, &quot;)
                // .append(&quot;arch.ka_sectie AS ontstaan_uit_sectie, &quot;)
                // .append(&quot;arch.ka_appartementsindex AS ontstaan_uit_appartementsindex, &quot;)
                // of misschien samengesteld?
                // .append(&quot;h.fk_sc_lh_koz_kad_identif AS overgegaan_in &quot;)
<span class="nc" id="L276">                .append(&quot;FROM kad_onrrnd_zk o &quot;)</span>
                // samengestelde app_re en kad_perceel als q
<span class="nc" id="L278">                .append(&quot;LEFT JOIN (SELECT  &quot;)</span>
<span class="nc" id="L279">                .append(&quot;  ar.sc_kad_identif, &quot;)</span>
<span class="nc" id="L280">                .append(&quot;  ar.ka_kad_gemeentecode, &quot;)</span>
<span class="nc" id="L281">                .append(&quot;  ar.ka_perceelnummer, &quot;)</span>
<span class="nc" id="L282">                .append(&quot;  null AS ka_deelperceelnummer, &quot;)</span>
<span class="nc" id="L283">                .append(&quot;  ar.ka_sectie, &quot;)</span>
<span class="nc" id="L284">                .append(&quot;  ar.ka_appartementsindex, &quot;)</span>
<span class="nc" id="L285">                .append(&quot;  null AS grootte_perceel, &quot;)</span>
<span class="nc" id="L286">                .append(&quot;  null AS x, &quot;)</span>
<span class="nc" id="L287">                .append(&quot;  null AS y &quot;)</span>
<span class="nc" id="L288">                .append(&quot;FROM app_re ar &quot;)</span>
<span class="nc" id="L289">                .append(&quot;UNION ALL SELECT &quot;)</span>
<span class="nc" id="L290">                .append(&quot;  p.sc_kad_identif, &quot;)</span>
<span class="nc" id="L291">                .append(&quot;  p.ka_kad_gemeentecode, &quot;)</span>
<span class="nc" id="L292">                .append(&quot;  p.ka_perceelnummer, &quot;)</span>
<span class="nc" id="L293">                .append(&quot;  p.ka_deelperceelnummer, &quot;)</span>
<span class="nc" id="L294">                .append(&quot;  p.ka_sectie, &quot;)</span>
<span class="nc" id="L295">                .append(&quot;  null AS ka_appartementsindex, &quot;)</span>
<span class="nc" id="L296">                .append(&quot;  p.grootte_perceel, &quot;)</span>
<span class="nc" id="L297">                .append(&quot;  ST_X(p.plaatscoordinaten_perceel) AS x, &quot;)</span>
<span class="nc" id="L298">                .append(&quot;  ST_Y(p.plaatscoordinaten_perceel) AS y &quot;)</span>
<span class="nc" id="L299">                .append(&quot;FROM kad_perceel p) q &quot;)</span>
                // einde samenstelling app_re en kad_perceel als q
<span class="nc" id="L301">                .append(&quot;ON o.kad_identif=q.sc_kad_identif &quot;)</span>
                // zakelijk recht erbij
<span class="nc" id="L303">                .append(&quot;LEFT JOIN zak_recht z ON o.kad_identif=z.fk_7koz_kad_identif &quot;)</span>
                // soort recht omschrijving
<span class="nc" id="L305">                .append(&quot;LEFT JOIN aard_verkregen_recht avr ON z.fk_3avr_aand=avr.aand &quot;)</span>
                // ontstaan uit
<span class="nc" id="L307">                .append(&quot;LEFT JOIN kad_onrrnd_zk_his_rel h ON o.kad_identif=h.fk_sc_lh_koz_kad_identif &quot;)</span>
                // BKP erbij
<span class="nc" id="L309">                .append(&quot;JOIN &quot;)</span>
<span class="nc" id="L310">                .append(TAX_JOIN_CLAUSE_TBL)</span>
                // objecten met datum begin geldigheid in de periode &quot;van&quot;/&quot;tot&quot; inclusief,
                // maar niet in de archief tabel met een datum voor &quot;van&quot;.
<span class="nc" id="L313">                .append(&quot;WHERE '[&quot;)</span>
<span class="nc" id="L314">                .append(df.format(van)).append(&quot;,&quot;).append(df.format(tot))</span>
<span class="nc" id="L315">                .append(&quot;]'::DATERANGE @&gt; o.dat_beg_geldh::date &quot;)</span>
<span class="nc" id="L316">                .append(&quot;AND o.kad_identif NOT IN (SELECT kad_identif FROM kad_onrrnd_zk_archief WHERE '&quot;)</span>
<span class="nc" id="L317">                .append(df.format(van)).append(&quot;'::date &lt; dat_beg_geldh::date) &quot;)</span>
<span class="nc" id="L318">                .append(&quot;AND z.fk_8pes_sc_identif IS NOT null&quot;);</span>

<span class="nc bnc" id="L320" title="All 2 branches missed.">        switch (f) {</span>
            case &quot;csv&quot;:
<span class="nc" id="L322">                return queryToCSV(workDir, &quot;NieuweOnroerendGoed.csv&quot;, sql.toString());</span>
            case &quot;json&quot;:
            default:
<span class="nc" id="L325">                return queryToJson(workDir, &quot;NieuweOnroerendGoed.json&quot;, &quot;nieuw&quot;, sql.toString());</span>
        }
    }

    /**
     * ophalen gekoppelde objecten [2.4]. Nieuwe objecten met bijbehoren adres
     * en/of adresbeschrijving.
     *
     * @param workDir directory waar resultaat wordt neergezet
     * @return aantal gekoppelde objecten
     */
    private long getGekoppeldeObjecten(File workDir) {
<span class="nc" id="L337">        StringBuilder sql = new StringBuilder(&quot;SELECT DISTINCT &quot;)</span>
<span class="nc" id="L338">                .append(&quot;adr.koz_identif, &quot;)</span>
<span class="nc" id="L339">                .append(&quot;adr.gemeentecode, &quot;)</span>
<span class="nc" id="L340">                .append(&quot;adr.sectie, &quot;)</span>
<span class="nc" id="L341">                .append(&quot;adr.perceelnummer, &quot;)</span>
<span class="nc" id="L342">                .append(&quot;adr.appartementsindex, &quot;)</span>
<span class="nc" id="L343">                .append(&quot;adr.loc_omschr, &quot;)</span>
<span class="nc" id="L344">                .append(&quot;adr.benoemdobj_identif, &quot;)</span>
<span class="nc" id="L345">                .append(&quot;adr.straatnaam, &quot;)</span>
<span class="nc" id="L346">                .append(&quot;adr.huisnummer, &quot;)</span>
<span class="nc" id="L347">                .append(&quot;adr.huisletter, &quot;)</span>
<span class="nc" id="L348">                .append(&quot;adr.huisnummer_toev, &quot;)</span>
<span class="nc" id="L349">                .append(&quot;adr.woonplaats, &quot;)</span>
<span class="nc" id="L350">                .append(&quot;adr.postcode &quot;)</span>
<span class="nc" id="L351">                .append(&quot;FROM &quot;).append(VIEW_KAD_ONRRND_ZK_ADRES).append(&quot; adr &quot;)</span>
<span class="nc" id="L352">                .append(&quot; WHERE '[&quot;)</span>
<span class="nc" id="L353">                .append(df.format(van)).append(&quot;,&quot;).append(df.format(tot)).append(&quot;]'::DATERANGE @&gt; adr.begin_geldigheid::date &quot;)</span>
<span class="nc" id="L354">                .append(&quot;AND adr.koz_identif NOT IN (SELECT kad_identif FROM kad_onrrnd_zk_archief WHERE '&quot;)</span>
<span class="nc" id="L355">                .append(df.format(van))</span>
<span class="nc" id="L356">                .append(&quot;'::date &lt; dat_beg_geldh::date) ORDER BY adr.koz_identif&quot;);</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">        switch (f) {</span>
            case &quot;csv&quot;:
<span class="nc" id="L359">                return queryToCSV(workDir, &quot;GekoppeldeObjecten.csv&quot;, sql.toString());</span>
            case &quot;json&quot;:
            default:
<span class="nc" id="L362">                return queryToJson(workDir, &quot;GekoppeldeObjecten.json&quot;, &quot;koppeling&quot;, sql.toString());</span>
        }
    }

    /**
     * ophalen vervallen percelen en appartementsrechten. [2.5] Het jongste
     * archief record van een object dat niet meer in de actuele tabel voorkomt.
     *
     * @param workDir directory waar resultaat wordt neergezet
     * @return aantal vervallen
     */
    private long getVervallenOnroerendGoed(File workDir) {
<span class="nc" id="L374">        StringBuilder sql = new StringBuilder(&quot;SELECT DISTINCT ON (arch.koz_identif) &quot;)</span>
                // TODO data uit RSGB heeft geen 0-padding
<span class="nc" id="L376">                .append(&quot;arch.koz_identif, &quot;)</span>
<span class="nc" id="L377">                .append(&quot;arch.eind_geldigheid, &quot;)</span>
<span class="nc" id="L378">                .append(&quot;arch.gemeentecode, &quot;)</span>
<span class="nc" id="L379">                .append(&quot;arch.sectie, &quot;)</span>
<span class="nc" id="L380">                .append(&quot;arch.perceelnummer, &quot;)</span>
<span class="nc" id="L381">                .append(&quot;arch.deelperceelnummer, &quot;)</span>
<span class="nc" id="L382">                .append(&quot;arch.appartementsindex &quot;)</span>
                // 0-padding
<span class="nc" id="L384">                .append(&quot;FROM &quot;)</span>
<span class="nc" id="L385">                .append(VIEW_KAD_ONRRND_ZK_ARCHIEF)</span>
<span class="nc" id="L386">                .append(&quot; arch &quot;)</span>
                // object heeft archief record in gevraagde periode
<span class="nc" id="L388">                .append(&quot;WHERE '[&quot;)</span>
<span class="nc" id="L389">                .append(df.format(van)).append(&quot;,&quot;).append(df.format(tot))</span>
<span class="nc" id="L390">                .append(&quot;]'::DATERANGE @&gt; arch.eind_geldigheid::date &quot;)</span>
                // object niet meer in actuele tabel
<span class="nc" id="L392">                .append(&quot;AND arch.koz_identif NOT IN (SELECT kad_identif FROM kad_onrrnd_zk) &quot;)</span>
                // alleen de jongste archief record
<span class="nc" id="L394">                .append(&quot;ORDER BY arch.koz_identif, arch.eind_geldigheid::date DESC&quot;);</span>

<span class="nc bnc" id="L396" title="All 2 branches missed.">        switch (f) {</span>
            case &quot;csv&quot;:
<span class="nc" id="L398">                return queryToCSV(workDir, &quot;VervallenOnroerendGoed.csv&quot;, sql.toString());</span>
            case &quot;json&quot;:
            default:
<span class="nc" id="L401">                return queryToJson(workDir, &quot;VervallenOnroerendGoed.json&quot;, &quot;vervallen&quot;, sql.toString());</span>
        }
    }

    /**
     * Ophalen gewijzigde oppervlakte [2.7]. Jongste archief perceel die in de
     * periode waarvan de oppervlakte anders is dan het actuele perceel.
     */
    private long getGewijzigdeOpp(File workDir) {
<span class="nc" id="L410">        StringBuilder sql = new StringBuilder(&quot;SELECT DISTINCT ON (za.kad_identif) &quot;)</span>
<span class="nc" id="L411">                .append(&quot;za.kad_identif, &quot;)</span>
                // TODO data uit RSGB heeft geen 0-padding
<span class="nc" id="L413">                .append(&quot;k.ka_kad_gemeentecode AS gemeentecode, &quot;)</span>
<span class="nc" id="L414">                .append(&quot;k.ka_sectie AS sectie, &quot;)</span>
<span class="nc" id="L415">                .append(&quot;k.ka_perceelnummer AS perceelnummer, &quot;)</span>
<span class="nc" id="L416">                .append(&quot;k.ka_deelperceelnummer AS deelperceelnummer, &quot;)</span>
                // 0-padding
<span class="nc" id="L418">                .append(&quot;za.dat_beg_geldh, &quot;)</span>
<span class="nc" id="L419">                .append(&quot;pa.grootte_perceel AS opp_oud, &quot;)</span>
<span class="nc" id="L420">                .append(&quot;k.grootte_perceel  AS opp_actueel &quot;)</span>
<span class="nc" id="L421">                .append(&quot;FROM kad_onrrnd_zk_archief za, kad_perceel_archief pa, kad_perceel k &quot;)</span>
                // perceel moet in de archief zitten in gevraagde periode
<span class="nc" id="L423">                .append(&quot;WHERE '[&quot;)</span>
<span class="nc" id="L424">                .append(df.format(van)).append(&quot;,&quot;).append(df.format(tot))</span>
<span class="nc" id="L425">                .append(&quot;]'::DATERANGE @&gt; za.dat_beg_geldh::DATE &quot;)</span>
<span class="nc" id="L426">                .append(&quot;AND za.dat_beg_geldh    = pa.sc_dat_beg_geldh &quot;)</span>
<span class="nc" id="L427">                .append(&quot;AND za.kad_identif      = pa.sc_kad_identif &quot;)</span>
<span class="nc" id="L428">                .append(&quot;AND za.kad_identif      = k.sc_kad_identif &quot;)</span>
<span class="nc" id="L429">                .append(&quot;AND pa.grootte_perceel != k.grootte_perceel &quot;)</span>
                // dubbelop vanwege grootte_perceel check
                // .append(&quot;AND za.clazz            = 'KADASTRAAL PERCEEL' &quot;)
                // perceel moet in de actueel zitten in de periode, anders vervallen of datafout
<span class="nc" id="L433">                .append(&quot;AND za.kad_identif IN ( SELECT kad_identif FROM kad_onrrnd_zk &quot;)</span>
<span class="nc" id="L434">                .append(&quot;WHERE '[&quot;)</span>
<span class="nc" id="L435">                .append(df.format(van)).append(&quot;,&quot;).append(df.format(tot))</span>
<span class="nc" id="L436">                .append(&quot;]'::DATERANGE @&gt; dat_beg_geldh::DATE ) &quot;)</span>
<span class="nc" id="L437">                .append(&quot;ORDER BY za.kad_identif, za.dat_beg_geldh DESC&quot;);</span>

<span class="nc bnc" id="L439" title="All 2 branches missed.">        switch (f) {</span>
            case &quot;csv&quot;:
<span class="nc" id="L441">                return queryToCSV(workDir, &quot;GewijzigdeOpp.csv&quot;, sql.toString());</span>
            case &quot;json&quot;:
            default:
<span class="nc" id="L444">                return queryToJson(workDir, &quot;GewijzigdeOpp.json&quot;, &quot;gewijzigdeopp&quot;, sql.toString());</span>
        }
    }

    /**
     * ophalen verkopen [2.6].
     *
     * @param workDir directory waar resultaat wordt neergezet
     * @return aantal verkopen
     */
    private long getVerkopen(File workDir) {
<span class="nc" id="L455">        StringBuilder sql = new StringBuilder(&quot;SELECT DISTINCT &quot;)</span>
<span class="nc" id="L456">                .append(&quot;bron.ref_id, &quot;)</span>
<span class="nc" id="L457">                .append(&quot;bron.datum::text as verkoopdatum, &quot;)</span>
<span class="nc" id="L458">                .append(&quot;tax.gemeentecode, &quot;)</span>
<span class="nc" id="L459">                .append(&quot;tax.sectie, &quot;)</span>
<span class="nc" id="L460">                .append(&quot;tax.perceelnummer, &quot;)</span>
<span class="nc" id="L461">                .append(&quot;tax.deelperceelnummer, &quot;)</span>
<span class="nc" id="L462">                .append(&quot;tax.appartementsindex, &quot;)</span>
                // altijd leeg want alleen als belastingplichtige onbekend is is verkoop relevant
<span class="nc" id="L464">                .append(&quot;kpr_nummer, &quot;)</span>
<span class="nc" id="L465">                .append(&quot;z.ar_teller AS aandeel_teller, &quot;)</span>
<span class="nc" id="L466">                .append(&quot;z.ar_noemer AS aandeel_noemer, &quot;)</span>
<span class="nc" id="L467">                .append(&quot;z.fk_3avr_aand AS rechtcode, &quot;)</span>
<span class="nc" id="L468">                .append(&quot;avr.omschr_aard_verkregenr_recht AS rechtomschrijving &quot;)</span>
                // verkoop + datum
<span class="nc" id="L470">                .append(&quot;FROM ( &quot;)</span>
<span class="nc" id="L471">                .append(&quot;  SELECT brondocument.ref_id, max(brondocument.datum) AS datum FROM brondocument WHERE brondocument.omschrijving = 'Akte van Koop en Verkoop' GROUP BY brondocument.ref_id) bron &quot;)</span>
                // samengestelde app_re en kad_perceel als q
<span class="nc" id="L473">                .append(&quot;LEFT JOIN (SELECT  &quot;)</span>
<span class="nc" id="L474">                .append(&quot;  ar.sc_kad_identif, &quot;)</span>
<span class="nc" id="L475">                .append(&quot;  ar.ka_kad_gemeentecode, &quot;)</span>
<span class="nc" id="L476">                .append(&quot;  ar.ka_perceelnummer, &quot;)</span>
<span class="nc" id="L477">                .append(&quot;  null AS ka_deelperceelnummer, &quot;)</span>
<span class="nc" id="L478">                .append(&quot;  ar.ka_sectie, &quot;)</span>
<span class="nc" id="L479">                .append(&quot;  ar.ka_appartementsindex &quot;)</span>
<span class="nc" id="L480">                .append(&quot;FROM app_re ar &quot;)</span>
<span class="nc" id="L481">                .append(&quot;UNION ALL SELECT &quot;)</span>
<span class="nc" id="L482">                .append(&quot;  p.sc_kad_identif, &quot;)</span>
<span class="nc" id="L483">                .append(&quot;  p.ka_kad_gemeentecode, &quot;)</span>
<span class="nc" id="L484">                .append(&quot;  p.ka_perceelnummer, &quot;)</span>
<span class="nc" id="L485">                .append(&quot;  p.ka_deelperceelnummer, &quot;)</span>
<span class="nc" id="L486">                .append(&quot;  p.ka_sectie, &quot;)</span>
<span class="nc" id="L487">                .append(&quot;  null AS ka_appartementsindex &quot;)</span>
<span class="nc" id="L488">                .append(&quot;FROM kad_perceel p) q &quot;)</span>
                // einde samenstelling app_re en kad_perceel als q
<span class="nc" id="L490">                .append(&quot;ON bron.ref_id=q.sc_kad_identif::text &quot;)</span>
<span class="nc" id="L491">                .append(&quot;LEFT JOIN zak_recht z ON bron.ref_id = z.fk_7koz_kad_identif::text &quot;)</span>
<span class="nc" id="L492">                .append(&quot;LEFT JOIN aard_verkregen_recht avr ON z.fk_3avr_aand = avr.aand &quot;)</span>
<span class="nc" id="L493">                .append(&quot;JOIN &quot;)</span>
                // levert b
<span class="nc" id="L495">                .append(TAX_JOIN_CLAUSE_TBL)</span>
<span class="nc" id="L496">                .append(&quot;WHERE '[&quot;)</span>
<span class="nc" id="L497">                .append(df.format(van)).append(&quot;,&quot;).append(df.format(tot))</span>
<span class="nc" id="L498">                .append(&quot;]'::DATERANGE @&gt; bron.datum &quot;)</span>
<span class="nc" id="L499">                .append(&quot;AND z.fk_8pes_sc_identif IS NOT null &quot;)</span>
                // alleen verkochte percelen waar belastingplichtige onbekend is
<span class="nc" id="L501">                .append(&quot; AND tax.kpr_nummer IS null &quot;);</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">        switch (f) {</span>
            case &quot;csv&quot;:
<span class="nc" id="L505">                return queryToCSV(workDir, &quot;Verkopen.csv&quot;, sql.toString());</span>
            case &quot;json&quot;:
            default:
<span class="nc" id="L508">                return queryToJson(workDir, &quot;Verkopen.json&quot;, &quot;verkopen&quot;, sql.toString());</span>
        }
    }

    /**
     * Nieuwe subjecten [2.8]. De voor het systeem nieuwe subjecten zijn de
     * subjecten van nieuwe kadastrale objecten die niet aan de
     * belastingplichtige kunnen worden gekoppeld.
     *
     * @param workDir directory waar resultaat wordt neergezet
     * @return aantal nieuwe subjecten
     */
    private long getNieuweSubjecten(File workDir) {
<span class="nc" id="L521">        StringBuilder sql = new StringBuilder(&quot;SELECT DISTINCT ON (q.naam) &quot;)</span>
<span class="nc" id="L522">                .append(&quot;q.begin_geldigheid, &quot;)</span>
<span class="nc" id="L523">                .append(&quot;q.soort, &quot;)</span>
<span class="nc" id="L524">                .append(&quot;q.geslachtsnaam, &quot;)</span>
<span class="nc" id="L525">                .append(&quot;q.voorvoegsel, &quot;)</span>
<span class="nc" id="L526">                .append(&quot;q.voornamen, &quot;)</span>
<span class="nc" id="L527">                .append(&quot;q.naam, &quot;)</span>
<span class="nc" id="L528">                .append(&quot;q.woonadres, &quot;)</span>
<span class="nc" id="L529">                .append(&quot;q.geboortedatum, &quot;)</span>
<span class="nc" id="L530">                .append(&quot;q.overlijdensdatum, &quot;)</span>
<span class="nc" id="L531">                .append(&quot;q.bsn, &quot;)</span>
<span class="nc" id="L532">                .append(&quot;q.rsin, &quot;)</span>
<span class="nc" id="L533">                .append(&quot;q.kvk_nummer, &quot;)</span>
<span class="nc" id="L534">                .append(&quot;q.straatnaam, &quot;)</span>
<span class="nc" id="L535">                .append(&quot;q.huisnummer, &quot;)</span>
<span class="nc" id="L536">                .append(&quot;q.huisletter, &quot;)</span>
<span class="nc" id="L537">                .append(&quot;q.huisnummer_toev, &quot;)</span>
<span class="nc" id="L538">                .append(&quot;q.postcode, &quot;)</span>
<span class="nc" id="L539">                .append(&quot;q.woonplaats &quot;)</span>
                // altijd null: tax.kpr_nummer
<span class="nc" id="L541">                .append(&quot;FROM &quot;).append(VIEW_KOZ_RECHTHEBBENDE).append(&quot; q &quot;)</span>
<span class="nc" id="L542">                .append(&quot;LEFT JOIN &quot;)</span>
<span class="nc" id="L543">                .append(TAX_JOIN_CLAUSE_VW)</span>
                // objecten met datum begin geldigheid in de periode &quot;van&quot;/&quot;tot&quot; inclusief,
                // maar niet in de archief tabel met een datum voor &quot;van&quot;.
<span class="nc" id="L546">                .append(&quot;WHERE '[&quot;)</span>
<span class="nc" id="L547">                .append(df.format(van)).append(&quot;,&quot;).append(df.format(tot))</span>
<span class="nc" id="L548">                .append(&quot;]'::DATERANGE @&gt; q.begin_geldigheid::date &quot;)</span>
<span class="nc" id="L549">                .append(&quot;AND q.koz_identif NOT IN (SELECT kad_identif FROM kad_onrrnd_zk_archief WHERE '&quot;)</span>
<span class="nc" id="L550">                .append(df.format(van)).append(&quot;'::date &lt; dat_beg_geldh::date) &quot;)</span>
                // die niet gekoppeld kunnen worden
<span class="nc" id="L552">                .append(&quot;AND tax.kpr_nummer IS NULL &quot;)</span>
                // alleen de eerste naam met de oudste datum
<span class="nc" id="L554">                .append(&quot;ORDER BY q.naam, q.begin_geldigheid ASC&quot;);</span>

<span class="nc bnc" id="L556" title="All 2 branches missed.">        switch (f) {</span>
            case &quot;csv&quot;:
<span class="nc" id="L558">                return queryToCSV(workDir, &quot;NieuweSubjecten.csv&quot;, sql.toString());</span>
            case &quot;json&quot;:
            default:
<span class="nc" id="L561">                return queryToJson(workDir, &quot;NieuweSubjecten.json&quot;, &quot;nieuwe_subjecten&quot;, sql.toString());</span>
        }
    }

    /**
     * Nieuwe subjecten in de gevraagde periode [2.9]. Nieuwe subjecten hebben
     * een record in de herkomst_metadata tabel met verwijzing naar subject en
     * met een datum binnen de gevraagde periode en zitten ook in de
     * ander_nat_prs tabel (want die zijn niet ingeschreven/geen bsn).
     *
     * @param workDir directory waar resultaat wordt neergezet
     * @return aantal bsn bijgewerkt
     */
    private long getBSNAangevuld(File workDir) {
<span class="nc" id="L575">        StringBuilder sql = new StringBuilder(&quot;SELECT &quot;)</span>
<span class="nc" id="L576">                .append(&quot;inp.bsn, &quot;)</span>
<span class="nc" id="L577">                .append(&quot;hm.datum::TEXT &quot;)</span>
                // (?)KPR nummer kan niet want er was toch geen bsn bekend dus waar komt dat dan vandaan?
<span class="nc" id="L579">                .append(&quot;FROM ingeschr_nat_prs inp &quot;)</span>
<span class="nc" id="L580">                .append(&quot;LEFT JOIN herkomst_metadata hm ON &quot;)</span>
<span class="nc" id="L581">                .append(&quot;inp.sc_identif = hm.waarde &quot;)</span>
<span class="nc" id="L582">                .append(&quot;WHERE inp.sc_identif IN (SELECT sc_identif FROM ander_nat_prs) &quot;)</span>
<span class="nc" id="L583">                .append(&quot;AND hm.tabel='subject' &quot;)</span>
<span class="nc" id="L584">                .append(&quot;AND '[&quot;)</span>
<span class="nc" id="L585">                .append(df.format(van)).append(&quot;,&quot;).append(df.format(tot))</span>
<span class="nc" id="L586">                .append(&quot;]'::DATERANGE @&gt; datum::DATE &quot;);</span>

<span class="nc bnc" id="L588" title="All 2 branches missed.">        switch (f) {</span>
            case &quot;csv&quot;:
<span class="nc" id="L590">                return queryToCSV(workDir, &quot;BsnAangevuld.csv&quot;, sql.toString());</span>
            case &quot;json&quot;:
            default:
<span class="nc" id="L593">                return queryToJson(workDir, &quot;BsnAangevuld.json&quot;, &quot;bsnaangevuld&quot;, sql.toString());</span>
        }
    }

    /**
     * Voert de sql query uit en schrijft het resultaat in het bestand in json
     * formaat.
     *
     * @param workDir directory waar json resultaat wordt neergezet
     * @param bestandsNaam naam van resultaat bestand
     * @param resultName naam van de json node met resultaten, default is
     * {@code results}
     * @param sql uit te voeren query
     * @param params optionele prepared statement params
     * @return aantal verwerkte records of -1 in geval van een fout
     */
    private long queryToJson(File workDir, String bestandsNaam, String resultName, String sql, String... params) {
<span class="nc" id="L610">        long count = -1;</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">        if (resultName == null) {</span>
<span class="nc" id="L612">            resultName = &quot;results&quot;;</span>
        }
<span class="nc" id="L614">        try (Connection c = ConfigUtil.getDataSourceRsgb().getConnection()) {</span>
<span class="nc" id="L615">            c.setReadOnly(true);</span>

<span class="nc" id="L617">            try (PreparedStatement stm = c.prepareStatement(sql)) {</span>
<span class="nc" id="L618">                int index = 0;</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">                for (String p : params) {</span>
<span class="nc" id="L620">                    stm.setString(index++, p);</span>
                }

<span class="nc" id="L623">                stm.setFetchDirection(ResultSet.FETCH_FORWARD);</span>
<span class="nc" id="L624">                stm.setFetchSize(JDBC_FETCH_SIZE);</span>
<span class="nc" id="L625">                LOG.debug(stm);</span>

<span class="nc" id="L627">                SimpleModule module = new SimpleModule();</span>
<span class="nc" id="L628">                ResultSetJSONSerializer serializer = new ResultSetJSONSerializer();</span>
<span class="nc" id="L629">                ObjectMapper mapper = new ObjectMapper();</span>

<span class="nc" id="L631">                try (ResultSet r = stm.executeQuery()) {</span>
<span class="nc" id="L632">                    module.addSerializer(serializer);</span>
<span class="nc" id="L633">                    mapper.registerModule(module);</span>
<span class="nc" id="L634">                    ObjectNode objectNode = mapper.createObjectNode();</span>
<span class="nc" id="L635">                    objectNode.putPOJO(resultName, r);</span>
<span class="nc" id="L636">                    mapper.writeValue(new FileOutputStream(workDir + File.separator + bestandsNaam), objectNode);</span>
                }
<span class="nc" id="L638">                count = serializer.getCount();</span>
            }

<span class="nc" id="L641">        } catch (SQLException | IOException e) {</span>
<span class="nc" id="L642">            LOG.error(</span>
<span class="nc" id="L643">                    String.format(&quot;Fout tijdens ophalen en uitschrijven gegevens (sql: %s, bestand: %s %s&quot;,</span>
                            sql,
                            workDir,
                            bestandsNaam), e);
<span class="nc" id="L647">        }</span>
<span class="nc" id="L648">        return count;</span>
    }

    private long queryToCSV(File workDir, String bestandsNaam, String sql, String... params) {
<span class="nc" id="L652">        long count = -1;</span>

<span class="nc" id="L654">        final String NL = System.getProperty(&quot;line.separator&quot;);</span>
<span class="nc" id="L655">        final String SEP = &quot;;&quot;;</span>

<span class="nc" id="L657">        try (Connection c = ConfigUtil.getDataSourceRsgb().getConnection()) {</span>
<span class="nc" id="L658">            c.setReadOnly(true);</span>

<span class="nc" id="L660">            try (PreparedStatement stm = c.prepareStatement(sql)) {</span>
<span class="nc" id="L661">                int index = 0;</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">                for (String p : params) {</span>
<span class="nc" id="L663">                    stm.setString(index++, p);</span>
                }

<span class="nc" id="L666">                stm.setFetchDirection(ResultSet.FETCH_FORWARD);</span>
<span class="nc" id="L667">                stm.setFetchSize(JDBC_FETCH_SIZE);</span>
<span class="nc" id="L668">                LOG.debug(stm);</span>

<span class="nc" id="L670">                try (ResultSet r = stm.executeQuery();</span>
<span class="nc" id="L671">                        FileOutputStream fos = new FileOutputStream(workDir + File.separator + bestandsNaam);</span>
<span class="nc" id="L672">                        Writer out = new OutputStreamWriter(new BufferedOutputStream(fos), &quot;UTF-8&quot;)) {</span>
<span class="nc" id="L673">                    ResultSetMetaData metaData = r.getMetaData();</span>
<span class="nc" id="L674">                    int numCols = metaData.getColumnCount();</span>

                    // schrijf kolommen
<span class="nc bnc" id="L677" title="All 2 branches missed.">                    for (int j = 1; j &lt; (numCols + 1); j++) {</span>
<span class="nc" id="L678">                        out.append(metaData.getColumnName(j));</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">                        if (j &lt; numCols) {</span>
<span class="nc" id="L680">                            out.append(SEP);</span>
                        } else {
<span class="nc" id="L682">                            out.append(NL);</span>
                        }
                    }

<span class="nc" id="L686">                    count = 0;</span>
                    // schrijf data
<span class="nc bnc" id="L688" title="All 2 branches missed.">                    while (r.next()) {</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">                        for (int k = 1; k &lt; (numCols + 1); k++) {</span>
                            // het zou mooier zijn om de type specifieke getters van de resultset te gebruiken,
                            // maar uiteindelijk doen we toch een toString() dus resultaat is gelijk.
<span class="nc" id="L692">                            String o = r.getString(k);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">                            out.append(o != null ? o : &quot;&quot;);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                            if (k &lt; numCols) {</span>
<span class="nc" id="L695">                                out.append(SEP);</span>
                            } else {
<span class="nc" id="L697">                                out.append(NL);</span>
                            }
                        }
<span class="nc" id="L700">                        count++;</span>
                    }
                }
            }
<span class="nc" id="L704">        } catch (SQLException | IOException e) {</span>
<span class="nc" id="L705">            LOG.error(</span>
<span class="nc" id="L706">                    String.format(&quot;Fout tijdens ophalen en uitschrijven gegevens (sql: %s, bestand: %s %s&quot;,</span>
                            sql,
                            workDir,
                            bestandsNaam), e);
<span class="nc" id="L710">        }</span>
<span class="nc" id="L711">        return count;</span>
    }

    private void initParams() {
<span class="nc" id="L715">        LOG.debug(&quot;laden van context params&quot;);</span>
<span class="nc" id="L716">        boolean use_mv = Boolean.parseBoolean(getContext().getServletContext().getInitParameter(&quot;use_mv&quot;));</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (use_mv) {</span>
<span class="nc" id="L718">            LOG.info(&quot;Gebruik materialized views in de queries.&quot;);</span>
<span class="nc" id="L719">            VIEW_KOZ_RECHTHEBBENDE = VIEW_KOZ_RECHTHEBBENDE.replaceFirst(&quot;vb_&quot;, &quot;mb_&quot;);</span>
<span class="nc" id="L720">            VIEW_KAD_ONRRND_ZK_ADRES = VIEW_KAD_ONRRND_ZK_ADRES.replaceFirst(&quot;vb_&quot;, &quot;mb_&quot;);</span>
<span class="nc" id="L721">            VIEW_KAD_ONRRND_ZK_ARCHIEF = VIEW_KAD_ONRRND_ZK_ARCHIEF.replaceFirst(&quot;vb_&quot;, &quot;mb_&quot;);</span>
        }

        try {
<span class="nc" id="L725">            JDBC_FETCH_SIZE = Integer.parseInt(getContext().getServletContext().getInitParameter(&quot;jdbc_fetch_size&quot;));</span>
<span class="nc" id="L726">            LOG.debug(&quot;Gebruik fetch size van &quot; + JDBC_FETCH_SIZE);</span>
<span class="nc" id="L727">        } catch (Exception e) {</span>
            // ignore
<span class="nc" id="L729">        }</span>
<span class="nc" id="L730">    }</span>

    public ActionBeanContext getContext() {
<span class="nc" id="L733">        return context;</span>
    }

    public void setContext(ActionBeanContext context) {
<span class="nc" id="L737">        this.context = context;</span>
<span class="nc" id="L738">    }</span>

    public Date getVan() {
<span class="nc" id="L741">        return van;</span>
    }

    public void setVan(Date van) {
<span class="nc" id="L745">        this.van = van;</span>
<span class="nc" id="L746">    }</span>

    public Date getTot() {
<span class="nc" id="L749">        return tot;</span>
    }

    public void setTot(Date tot) {
<span class="nc" id="L753">        this.tot = tot;</span>
<span class="nc" id="L754">    }</span>

    public String getF() {
<span class="nc" id="L757">        return f;</span>
    }

    public void setF(String f) {
<span class="nc" id="L761">        this.f = f;</span>
<span class="nc" id="L762">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>